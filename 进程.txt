=====================进程=======================
查看进程信息：
ps
	-ef
	-aux
	
top

/proc

修改进程优先级：
nice -n x ./test	//以x的优先级运行./test
	x取值-20~19
	普通用户不能设置负优先级，默认是0
	
renice -n x yyy		//改变正在运行进程的优先级
	x取值-20~19
	y是进程号(PID)
	普通用户不能设置负优先级，默认是0
-20~19：数值越小，优先级越大

./test & 	//运行程序并放在后台运行
fg 1		//将进程号是 1 的进程放到前台运行
ctrl+z		//暂停程序
bg 2		//将程序放到后台运行
jobs		//查看后台进程
bg			//将挂起的进程在后台运行
fg			//把后台运行的进程放到前台运行

===============进程编程=============
进程类型：交互进程，批处理进程，守护进程(监控进程)

pid_t fork(void)
创建进程，通过返回值判断父子进程
成功：在父进程中返回子进程号，在子进程中返回0
失败：在父进程返回-1，没有子进程被创建，并设置错误码
可以使用 if 或 switch 结构判断 fork 返回值

父子进程：
子进程继承了父进程的内容
父子进程有独立的地址空间，互不影响
若父进程先结束
	子进程成为孤儿进程，被init进程收养
	子进程变成后台进程
若子进程先结束
	父进程没有及时回收，子进程变成僵尸进程
子进程从fork函数的下条语句开始运行，子进程不执行fork函数
父子进程的执行顺序不确定，可能是子进程先执行，也可能是父进程先执行

getpid()	//获取进程号

void exit(int status)
C库函数，结束当前进程，结束进程时会刷新流缓冲区
void _exit(int status)
内核函数，结束当前进程，不会刷新流缓冲区
status：做为返回值

int execl(const char *path, const char *arg, .../* (char  *) NULL */)
int execlp(const char *file, const char *arg, .../* (char  *) NULL */);
执行可执行文件/程序
进程(父进程)当前内容(数据,代码等)被指定的程序替换
注意：子进程调用exec函数族成功时，子进程的内容被替换了，所以子进程中exec函数后面的代码都不会被执行。失败则继续执行子进程后面的代码
execl的常用方法：
	1.实现让父子进程执行不同的程序：
		1.父进程创建子进程
		2.子进程调用execl函数族,子进程被execl调用的程序/可执行文件替代
		3.父进程不受影响
	例子：shell本身是一个进程，在执行ls时，shell进程创建一个子进程，子进程调用execl函数去执行ls程序，子进程除了进程号外，其它内容被ls程序替代。
	2.当进程认为自己不能再为系统和用户做出任何贡献时，就可以调用exec函数族中的任意一个函数让自己重生
path：执行的程序名称，包含路径
file：执行的程序名称，自动在PATH中查找
arg：传递给执行的程序的参数列表，第一个arg[0]是程序的名称
最后一个参数必须是NULL
成功：执行指定的程序，没有返回值
失败：返回-1
例：
execl("/bin/ls","ls","-a","-l","/etc",NULL)
execlp("ls","ls","-a","-l","/etc",NULL)

int execv(const char *path, char *const argv[])
int execvp(const char *file, char *const argv[])
同属与exec函数族，与上面两个不同指出是argv参数，这两个函数的argv封装成了数组，跟main函数的参数一样
成功：执行指定的程序，没有返回值
失败：返回-1
例：
char *arg[]={"ls","-a","-l","/etc",NULL};
execv("/bin/ls",arg);

进程回收：
pid_t wait(int *wstatus);
成功：返回回收子进程的进程号
失败：返回-1
若子进程没有结束，父进程一直阻塞
若有多个子进程，那个先结束就先回收
wstatus指定保存子进程返回值和结束方式的地址
wstatus为NULL表示直接释放子进程PCB，不接收返回值
子进程通过 exit/_exit/return 会返回某个值(0-255)
父进程调用wait(&wstatus)回收；
通过以下宏判断wstatus的类型
WIFEXITED(wstatus)		//判断子进程是否正常结束
WEXITSTATUS(wstatus)	//获取子进程返回值
WIFSIGNALED(wstatus)	//判断子进程是否被信号结束
WTERMSIG(wstatus)		//获取结束子进程的信号类型
WCOREDUMP(wstatus)		//暂未注释
WIFSTOPPED(wstatus)		//暂未注释
WSTOPSIG(wstatus)		//暂未注释
WIFCONTINUED(wstatus)	//暂未注释

pid_t waitpid(pid_t pid, int *wstatus, int options);
以指定的方式回收特定的进程
pid：用于指定回收的子进程PID，-1表示回收任意子进程
wstatus：保存子进程返回值和结束方式的地址
option：指定回收方式，0(阻塞)或WNOHANG(非阻塞)
成功：返回子进程的pid或0(子进程未结束)
失败：返回-1

守护进程：
1.始终在后台运行
2.独立于任何终端
3.周期性的执行某个任务或等待处理特定事件

每个进程属于一个进程组
会话是一个或多个进程组的集合。通常用户打开一个终端时，系统会创建一个会话。所有通过该终端运行的进程都属于这个会话
终端关闭时，所有相关进程会被结束

创建守护进程：
	1.创建子进程，父进程退出，子进程变成孤儿进程，被init进程回收，子进程在后台运行
	2.子进程创建新会话，子进程成为新会话的组长，子进程脱离原先终端
	setsid()用于创建新会话，成功返回新会话ID，失败-1
	3.更改当前工作目录,守护进程一直在后台运行，其工作目录不能被卸载，所以一般设定工作目录为下面两个目录
	chdir("/");或chdir("/tmp") //两个目录的权限不同，成功：0，失败：-1
	4.重设文件权限掩码，文件权限掩码设置为0，该掩码只影响当前进程
	umask(0)	//返回之前的掩码，绝对成功
	5.关闭打开的文件描述符，关闭所有从父进程继承的打开文件，需要其它文件可以手动打开，已脱离终端，所以stdin/stdout/stderr无法在使用
	getdtablesize()		//获取系统可以打开的最多文件数，没打开的也关闭


kill -l		查看所有信号的类型















